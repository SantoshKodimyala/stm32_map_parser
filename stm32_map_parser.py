#!/usr/bin/env python3
"""
/**
 * @file    STM32_Map_Parser.py
 * @brief   Parses STM32CubeIDE .map files to extract symbol info.
 * @github  https://github.com/SantoshKodimyala/stm32_map_parser/
 * @author  Santosh Kodimyala
 * @version 1.0
 * @date    2025-07-17
 *
 * A utility to parse STM32CubeIDE generated map files and extract symbol information.
 * Supports extracting symbol addresses, generating symbol tables, and counting different
 * types of symbols (functions, global variables, local variables).
 */
"""


import sys
import os
import re
import argparse
from typing import Dict, List, Tuple, Optional


class MapFileParser:
    """
    Parser for STM32CubeIDE map files.
    
    This class handles the parsing of .map files generated by STM32CubeIDE
    and extracts symbol information including addresses, types, and counts.
    """
    
    def __init__(self, map_file_path: str):
        """
        Initialize the parser with a map file path.
        
        Args:
            map_file_path (str): Path to the .map file
        """
        self.map_file_path = map_file_path
        self.symbols = {}  # Dictionary to store symbol -> address mapping
        self.functions = {}  # Dictionary to store function symbols
        self.global_vars = {}  # Dictionary to store global variable symbols
        self.local_vars = {}  # Dictionary to store local variable symbols
        
    def parse_map_file(self) -> None:
        """
        Parse the map file and extract symbol information.
        
        Raises:
            FileNotFoundError: If the map file doesn't exist
            IOError: If there's an error reading the file
        """
        try:
            with open(self.map_file_path, 'r', encoding='utf-8', errors='ignore') as file:
                content = file.read()
                
            # Parse different sections of the map file
            self._parse_symbol_table(content)
            self._categorize_symbols(content)
            
        except FileNotFoundError:
            raise FileNotFoundError(f"Map file not found: {self.map_file_path}")
        except IOError as e:
            raise IOError(f"Error reading map file: {e}")
    
    def _parse_symbol_table(self, content: str) -> None:
        """
        Parse the symbol table section of the map file.
        
        Args:
            content (str): Complete content of the map file
        """
        # Look for symbol table section (usually starts with "Symbol Table:")
        symbol_section_patterns = [
            r'Symbol Table:.*?(?=\n\S|\Z)',
            r'\.text\s+0x[0-9a-fA-F]+\s+0x[0-9a-fA-F]+.*?(?=\n\S|\Z)',
            r'^\s*0x[0-9a-fA-F]+\s+\S+',  # Generic pattern for address symbol pairs
        ]
        
        # Pattern to match symbol entries: address symbol_name
        symbol_pattern = r'^\s*0x([0-9a-fA-F]+)\s+([^\s]+)'
        
        lines = content.split('\n')
        
        for line in lines:
            # Try to match symbol entries
            match = re.match(symbol_pattern, line)
            if match:
                address = match.group(1)
                symbol = match.group(2)
                
                # Convert hex address to integer for easier handling
                try:
                    addr_int = int(address, 16)
                    self.symbols[symbol] = f"0x{addr_int:08X}"
                except ValueError:
                    continue
            
            # Also look for linker map format: symbol = address
            assignment_pattern = r'^\s*([^\s=]+)\s*=\s*0x([0-9a-fA-F]+)'
            match = re.match(assignment_pattern, line)
            if match:
                symbol = match.group(1)
                address = match.group(2)
                try:
                    addr_int = int(address, 16)
                    self.symbols[symbol] = f"0x{addr_int:08X}"
                except ValueError:
                    continue
    
    def _categorize_symbols(self, content: str) -> None:
        """
        Categorize symbols into functions, global variables, and local variables.
        
        Args:
            content (str): Complete content of the map file
        """
        lines = content.split('\n')
        
        for symbol, address in self.symbols.items():
            # Skip compiler-generated symbols and linker symbols
            if (symbol.startswith('_') and 
                (symbol.startswith('__') or 
                 symbol.startswith('_e') or 
                 symbol.startswith('_s'))):
                continue
            
            # Categorize based on symbol characteristics
            if self._is_function_symbol(symbol, content):
                self.functions[symbol] = address
            elif self._is_global_variable(symbol, content):
                self.global_vars[symbol] = address
            elif self._is_local_variable(symbol, content):
                self.local_vars[symbol] = address
    
    def _is_function_symbol(self, symbol: str, content: str) -> bool:
        """
        Determine if a symbol represents a function.
        
        Args:
            symbol (str): Symbol name
            content (str): Map file content
            
        Returns:
            bool: True if symbol is a function
        """
        # Look for function indicators in the map file
        function_indicators = [
            f'{symbol}()',
            f'*{symbol}*',
            f'.text.{symbol}',
        ]
        
        for indicator in function_indicators:
            if indicator in content:
                return True
        
        # Check if symbol appears in .text section
        text_pattern = rf'\.text\.[^\s]*{re.escape(symbol)}'
        if re.search(text_pattern, content, re.IGNORECASE):
            return True
        
        return False
    
    def _is_global_variable(self, symbol: str, content: str) -> bool:
        """
        Determine if a symbol represents a global variable.
        
        Args:
            symbol (str): Symbol name
            content (str): Map file content
            
        Returns:
            bool: True if symbol is a global variable
        """
        # Look for global variable indicators
        global_indicators = [
            f'.data.{symbol}',
            f'.bss.{symbol}',
            f'.rodata.{symbol}',
        ]
        
        for indicator in global_indicators:
            if indicator in content:
                return True
        
        # Check if symbol appears in data/bss sections
        data_pattern = rf'\.(?:data|bss|rodata)\.[^\s]*{re.escape(symbol)}'
        if re.search(data_pattern, content, re.IGNORECASE):
            return True
        
        return False
    
    def _is_local_variable(self, symbol: str, content: str) -> bool:
        """
        Determine if a symbol represents a local variable.
        
        Args:
            symbol (str): Symbol name
            content (str): Map file content
            
        Returns:
            bool: True if symbol is a local variable
        """
        # Local variables are typically harder to identify in map files
        # as they might not always be present. This is a basic heuristic.
        
        # If it's not a function or global variable, and contains certain patterns
        if not self._is_function_symbol(symbol, content) and not self._is_global_variable(symbol, content):
            # Check for local variable patterns (file-specific symbols)
            if '.' in symbol and not symbol.startswith('_'):
                return True
        
        return False
    
    def get_symbol_address(self, symbol: str) -> Optional[str]:
        """
        Get the memory address of a specific symbol.
        
        Args:
            symbol (str): Symbol name to look up
            
        Returns:
            Optional[str]: Memory address as hex string, or None if not found
        """
        return self.symbols.get(symbol)
    
    def generate_symbol_table(self, output_file: str) -> None:
        """
        Generate a tab-separated file with symbol vs memory address.
        
        Args:
            output_file (str): Path to output file
        """
        try:
            with open(output_file, 'w', encoding='utf-8') as file:
                file.write("Symbol\tAddress\n")
                
                # Sort symbols by address for better readability
                sorted_symbols = sorted(self.symbols.items(), 
                                      key=lambda x: int(x[1], 16))
                
                for symbol, address in sorted_symbols:
                    file.write(f"{symbol}\t{address}\n")
                    
            print(f"Symbol table generated: {output_file}")
            
        except IOError as e:
            raise IOError(f"Error writing symbol table: {e}")
    
    def get_symbol_counts(self) -> Dict[str, int]:
        """
        Get counts of different types of symbols.
        
        Returns:
            Dict[str, int]: Dictionary with counts of functions, global vars, local vars
        """
        return {
            'functions': len(self.functions),
            'global_variables': len(self.global_vars),
            'local_variables': len(self.local_vars),
            'total_symbols': len(self.symbols)
        }
    
    def print_symbol_counts(self) -> None:
        """Print symbol counts to console."""
        counts = self.get_symbol_counts()
        
        print("\nSymbol Counts:")
        print(f"Functions: {counts['functions']}")
        print(f"Global Variables: {counts['global_variables']}")
        print(f"Local Variables: {counts['local_variables']}")
        print(f"Total Symbols: {counts['total_symbols']}")


def main():
    """Main function to handle command line arguments and execute parser."""
    parser = argparse.ArgumentParser(
        description="Parse STM32CubeIDE map files and extract symbol information",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s -f firmware.map -t symbols.txt
  %(prog)s -f firmware.map -s main -s SystemInit
  %(prog)s -f firmware.map -c
  %(prog)s -f firmware.map -t symbols.txt -c -s main
        """
    )
    
    parser.add_argument('-f', '--file', required=True,
                       help='Path to the STM32CubeIDE map file')
    
    parser.add_argument('-t', '--table', 
                       help='Generate tab-separated symbol table file')
    
    parser.add_argument('-s', '--symbol', action='append',
                       help='Get memory address of specific symbol(s)')
    
    parser.add_argument('-c', '--count', action='store_true',
                       help='Display count of functions, global and local variables')
    
    args = parser.parse_args()
    
    # Validate map file exists
    if not os.path.exists(args.file):
        print(f"Error: Map file '{args.file}' not found", file=sys.stderr)
        sys.exit(1)
    
    try:
        # Create parser instance and parse the map file
        map_parser = MapFileParser(args.file)
        print(f"Parsing map file: {args.file}")
        map_parser.parse_map_file()
        
        # Generate symbol table if requested
        if args.table:
            map_parser.generate_symbol_table(args.table)
        
        # Look up specific symbols if requested
        if args.symbol:
            print("\nSymbol Address Lookup:")
            for symbol in args.symbol:
                address = map_parser.get_symbol_address(symbol)
                if address:
                    print(f"{symbol}: {address}")
                else:
                    print(f"{symbol}: Not found")
        
        # Print symbol counts if requested
        if args.count:
            map_parser.print_symbol_counts()
        
        # If no specific action requested, show basic info
        if not any([args.table, args.symbol, args.count]):
            print(f"\nParsed {len(map_parser.symbols)} symbols from map file")
            print("Use -h for help on available options")
            
    except (FileNotFoundError, IOError) as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Unexpected error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
